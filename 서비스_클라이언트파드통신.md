# 서비스: 클라이언트가 파드를 검색하고 통신을 가능하게 함
## 서비스
- 쿠버네티스의 서비스: 동일한 서비스를 제공하는 파드 그룹에 지속적인 단일 접점을 만들려고 할 때 생성하는 리소스.
- 각 서비스는 서비스가 존재하는 동안 절대 바뀌지 않는 IP주소, 포트가 있다.   
- 클라이언트는 해당 IP, 포트로 접속한 다음 해당 서비스를 지원하는 파드 중 하나로 연결된다.   
이런 방식으로 서비스의 클라이언트는 서비스를 제공하는 개별 파드의 위치를 알 필요가 없다.   

### 서비스 생성
**정확히 어떤 파드가 서비스의 일부분인지 아닌지를 정의하는 방법은?**   
레이블 셀렉터를 이용하면 된다.   
rc와 기타 파드 컨트롤러에서 레이블 셀렉터를 사용해 동일한 세트에 속하는 파드를 지정했듯이,   
서비스에도 동일한 메커니즘으로 소속 파드를 지정한다.   

생성하는 방법은 다음과 같다.   
- kubectl expose 명령으로 생성
  ~~~
  $ kubectl expose <pod_selector> <name> --type=<service_type> --name <service_name>
  example: 
  $ kubectl expose rc kubia --type=LoadBalancer --name kubia-http
  ~~~
  위에서 예시 명령은 "kubia"라는 이름의 RC을 노출시켜서 LoadBalancer 유형의 "kubia-http"라는 이름의 서비스를 생성한 것이다.
- YAML descriptor로 생성
  ~~~
  apiVersion: v1
  kind: Service
  metadata:
    name: kubia
  spec:
    ports:
    - port: 80          # 서비스가 사용할 포트(노출될 포트)
      targetPort: 8080  # 서비스가 포워드할 컨테이너 포트
    selector:
      app: kubia        # app=kubia 레이블이 있는 모든 파드가 이 서비스에 속한다.
  ~~~
### 서비스 목록 확인하기
~~~
$ kubectl get svc
~~~
출력 결과에서 보이는 CLUSTER-IP 열의 IP 주소는 서비스에 할당된 클러스터 IP이므로    
클러스터 내부에서만 액세스할 수 있다.   
### 서비스로 요청 확인(테스트)하는 방법 
- 로그 검사: 서비스의 클러스터 IP로 요청을 보내고 응답을 로그로 남기는 파드를 만들기.
- ssh 접속: 쿠버네티스 노드로 ssh 접속하고 curl 명령을 실행하기.
- kubectl exec: k exec 명령어로 기존 파드에서 curl 명령을 실행하기.
#### 실행 중인 컨테이너에 원격으로 명령어 실행
kubectl exec 명령어를 사용하면 기존 파드의 컨테이너 내에서 원격으로 임의의 명령어 실행이 가능하다.   
~~~
$ kubectl exec <pod_name> -- <command>
example:
$ kubectl exec kubia-7nog1 -- curl -s http://10.111.249.153
~~~
예시 명령어는 command를 실행시킬 파드를 정하고 서비스의 클러스터 IP로 HTTP 요청을 전송한 것이다.   
#### 명령어 실행 후 동작 과정
![스크린샷, 2021-05-15 05-57-37](https://user-images.githubusercontent.com/49184890/118349118-bcf12780-b589-11eb-9ed2-543ef4b200d3.png)   
서비스의 세션 어피니티를 지정하지 않았으므로 동일한 명령을 더 실행하면 동일한 클라이언트에서 요청하더라도    
서비스 프록시가 임의의 파드를 선택해 연결을 전달하기 때문에 요청할 때마다 다른 파드가 선택된다.   
#### 서비스의 세션 어피니티(sessionAffinity) 구성
세션 어피니티 속성값으로 다음 2가지를 지정할 수 있다.
- None          (default값이다.)
- ClientIP
서비스의 세션 어피니티 속성을 ClientIP로 설정하면 서비스 프록시는 동일한 클라이언트 IP의 모든 요청을 동일한 파드로 전달한다.   
~~~
apiVersion: v1
kind: Service
metadata:
  name: kubia
spec:
  sessionAffinity: ClientIP
  ...
~~~
위와 같이 spec 아래에 세션 어피니티를 지정한다.   
#### 서비스 정의: 멀티 포트 지정
~~~
apiVersion: v1
kind: Service
metadata:
  name: kubia
spec:
  ports:
  - name: http
    port: 80
    targetPort: 8080
  - name: https
    port: 443
    targetPort: 8443
  selector:
    app: kubia
~~~
#### 파드 정의: 포트 이름 사용
파드 리소스의 YAML 파일에서 파드의 포트에 이름을 붙여주자.   
~~~
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: kubia
    ports:
    - name: http          # Port 8080의 이름은 http이다.
      containerPort: 8080
    - name: https         # Port 8443의 이름은 https이다.
      containerPort: 8443
~~~
#### 서비스 정의: 포트 이름으로 포트 참조하기
이름으로 포트를 참조할 수 있다.   
~~~
apiVersion: v1
kind: Service
metadata:
  name: kubia
spec:
  ports:
  - name: http
    port: 80
    targetPort: http    # 앞서 파드 정의에서 8080에 http라는 이름을 부여했다.
  - name: https
    port: 443
    targetPort: https   # 앞서 파드 정의에서 8443에 https라는 이름을 부여했다.
~~~
### 서비스 검색 방법 2가지
쿠버네티스는 클라이언트 파드가 서비스의 IP와 포트를 검색할 수 있는 방법을 제공한다.   
방법으로 다음 2가지가 있다.   
- 환경변수를 통한 검색
- DNS를 통한 검색
#### 서비스 검색 방법 1: 환경변수를 통한 서비스 검색
아래 명령어를 입력하여 대상 파드의 컨테이너 내부에서 env 명령어를 실행하여 환경변수를 조회한다.   
_주의할 것은 파드를 만든 후에 서비스를 만들면 서비스에 대한 환경변수를 설정할 수 없는 것이다._    
따라서 kubectl delete pods --all 명령으로 rc나 rs가 파드를 새로 만들 수 있도록 한다.   
~~~
$ kubectl exec <pod_name> env
~~~
출력되는 환경변수 목록 중   
<service_name>_SERVICE_HOST는 서비스의 클러스터 IP다.   
<service_name>_SERVICE_PORT는 서비스가 제공되는 포트다.   

#### 서비스 검색 방법 2: DNS를 통한 서비스 검색
#### FQDN을 통한 서비스 연결
FQDN으로 kubia 서비스에 액세스하자.   
먼저 파드의 컨테이너 내에서 bash 셸을 실행하고 curl 명령어를 사용해 kubia 서비스에 액세스한다.   
~~~
$ kubectl exec -it kubia-3inly bash

root@kubia-3inly:/# curl http://kubia.default.svc.cluster.local

root@kubia-3inly:/# curl http://kubia.default

root@kubia-3inly:/# curl http://kubia
~~~
파드 컨테이너 내부의 DNS resolver가 구성돼 있기 때문에 네임스페이스와 svc.cluster.local 접미사를 생략할 수 있다.   
컨테이너에서 /etc/resolv.conf 파일을 보면 이해할 수 있다.   
~~~
root@kubia-3inly:/# cat /etc/resolv.conf
search default.svc.cluster.local svc.cluster.local cluster.local ...
~~~
   
### 클러스터 외부에 있는 서비스 연결   
지금까지는 클러스터 내부에서 실행 중인 하나 이상의 파드와의 통신을 지원하는 서비스였다.   
그러나 쿠버네티스 서비스 기능으로 외부 서비스를 노출하려는 경우가 있을 수 있다. 서비스가 클러스터 내에 있는 파드로 연결을 전달하는 게 아니라, 외부 IP와 포트로 연결을 전달하는 것이다.   
클러스터에서 실행 중인 클라이언트 파드는 내부 서비스에 연결하는 것처럼 외부 서비스에 연결할 수 있다.   

#### 서비스 엔드포인트 소개
서비스 엔드포인트 전에 먼저 서비스를 좀 더 살펴보자.   
서비스는 파드에 직접 연결되지 않는다. 대신 엔드포인트 리소스가 그 사이에 있다.   
kubectl describe 명령을 사용하여 엔드포인트를 확인할 수 있다.   
~~~
$ kubectl describe svc kubia
~~~
앤드포인트 리소스는 서비스로 노출되는 파드의 IP 주소와 포트 목록이다.   
~~~
$ kubectl get endpoints kubia
~~~
#### 서비스 엔드포인트 수동 구성
서비스의 엔드포인트를 서비스와 분리하면 엔드포인트를 수동으로 구성하고 업데이트할 수 있다.   
파드 셀렉터 없이 서비스를 만들면 쿠버네티스는 엔드포인트 리소스를 생성하지 않는다.   
다음과 같이 셀렉터 없이 서비스를 생성하고 셀렉터가 없는 서비스에 관한 엔드포인트 리소스를 생성해보자.   
- 셀렉터 없이 서비스 생성   
  ~~~
  apiVersion: v1
  kind: Service
  metadata:
    name: external-service  # 서비스의 이름은 엔드포인트 오브젝트 이름과 동일해야 한다.
  spec:                     # 셀렉터가 정의돼 있지 않다.
    ports:
    - port: 80
  ~~~
- 셀렉터가 없는 서비스에 관한 엔드포인트 리소스 생성   
  ~~~
  apiVersion: v1
  kind: Endpoints           # Endpoints는 별도의 리소스(서비스 속성 아님)
  metadata:
    name: external-service  # 엔드포인트 오브젝트의 이름은 서비스 이름과 일치해야 한다.
  subsets:
    - addresses:
      - ip: 11.11.11.11     # 서비스가 연결을 전달할 엔드포인트의 IP
      - ip: 22.22.22.22     # 서비스가 연결을 전달할 엔드포인트의 ip
      ports:
      - port: 80            # 엔드포인트의 대상 포트
  ~~~
엔드포인트 오브젝트는 서비스와 이름이 같아야 하고 서비스를 제공하는 대상 외부의 IP 주소와 포트 목록을 가져야 한다.   
서비스가 만들어진 후 만들어진 컨테이너에는 서비스의 환경변수가 포함되며 IP:Port 쌍에 대한 모든 연결은 서비스 엔드포인트 간에 로드밸런싱한다.   
![스크린샷, 2021-06-16 05-56-02](https://user-images.githubusercontent.com/49184890/122122369-ad564e80-ce67-11eb-8d89-c99812f4a877.png)   
#### 외부 서비스를 위한 별칭 생성
서비스의 엔드포인트를 수동으로 구성해 외부 서비스를 노출하는 대신 좀 더 간단한 방법으로 FQDN(정규화된 도메인 이름)으로 외부 서비스를 참조할 수 있다.   

- ExternelName 서비스 생성   
  외부 서비스의 별칭으로 사용되는 서비스를 만들려면 spec 내부의 type 필드를 ExternalName으로 설정해 서비스 리소스를 만든다.   
  api.somecompany.com에 공개 API가 있다고 가정하자. 다음 예제에 표시도니 대로 이를 가리키는 서비스를 정의할 수 있다.   
  ~~~
  apiVersion: v1
  kind: Service
  metadata:
    name: external-service
  spec:
    type: ExternalName
    externalName: api.somecompany.com
    ports:
    - port: 80
  ~~~
서비스가 생성되면 파드는 external-service.default.svc.cluster.local 도메인 이름으로 외부 서비스에 연결할 수 있다.   
이렇게 하면 서비스를 사용하는 파드에서 실제 서비스 이름과 위치가 숨겨져 나중에 externalName 속성을 변경하거나 유형을 다시 ClusterIP로 변경하고 서비스 스펙을 만들어 수정하면 다른 서비스를 가리키도록 할 수 있다.   
ExternalName 서비스는 DNS 레벨에서만 구현된다.   

### 외부 클라이언트에 서비스 노출
지금까지는 클러스터 내부에서 파드가 서비스를 사용하는 방법을 알아봤다. 그러나 다음 그림과 같이 Front-End 웹 서버와 같은 특정 서비스를 외부에 노출해 외부 클라이언트가 액세스할 수 있게 하고 싶을 수 있다.   
![스크린샷, 2021-06-16 06-30-53](https://user-images.githubusercontent.com/49184890/122126272-7898c600-ce6c-11eb-9b5d-a19d745f9411.png)   
#### 외부에서 서비스를 액세스할 수 있는 몇 가지 방법.   
- 노드포트로 서비스 유형 설정
- 서비스 유형을 노드포트 유형의 확장인 로드밸런서로 설정
- 단일 IP 주소로 여러 서비스를 노출하는 인그레스 리소스 만들기
